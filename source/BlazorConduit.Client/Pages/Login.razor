@page "/login"

@using BlazorConduit.Client.Models.Authentication.Dtos
@using BlazorConduit.Client.Models.Authentication.Requests
@using BlazorConduit.Client.Models.Authentication.Validation
@using BlazorConduit.Client.Services
@using BlazorConduit.Client.Store.State
@using Fluxor

@inject IState<UserState> State
@inject StateFacade StateFacade

<div class="auth-page">
    <div class="container page">
        <div class="row">

            <div class="col-md-6 offset-md-3 col-xs-12">
                <h1 class="text-xs-center">Sign in</h1>
                <p class="text-xs-center">
                    <a href="/register">Need an account?</a>
                </p>



                <EditForm EditContext="editContext" OnSubmit="OnSignInClicked">
                    <DataAnnotationsValidator />

                    @*
                        Bit of a hack, but alas, my StackOverflow skills were overcome when searching on how
                        override the custom CSS for the <ValidationSummary /> component. This does the job for now.
                    *@
                    @if (!isValid)
                    {
                        <ul class="error-messages">
                            @* Display any validation errors *@
                            @if (!(editContext is null))
                            {
                                @foreach (var errorMessage in editContext.GetValidationMessages())
                                {
                                    <li>@errorMessage</li>
                                }
                            }

                            @* Display any errors returned from the API response *@
                            @if (State.Value.HasCurrentErrors)
                            {
                                @* Let the compiler know we have current errors since it is a nullable field, and already null checked with HasCurrentErrors *@
                                @foreach (var error in State.Value.CurrentErrors!)
                                {
                                    <li>@error</li>

                                }
                            }
                        </ul>
                    }

                    <fieldset class="form-group">
                        <InputText class="form-control form-control-lg" placeholder="Email" @bind-Value="validationModel.Email" />
                    </fieldset>
                    <fieldset class="form-group">
                        <InputText class="form-control form-control-lg" placeholder="Password" type="password" @bind-Value="validationModel.Password" />
                    </fieldset>
                    <button type="submit" class="btn btn-lg btn-primary pull-xs-right">
                        Sign in
                    </button>
                </EditForm>
            </div>

        </div>
    </div>
</div>

@code {

    private LoginUserValidationModel validationModel = new LoginUserValidationModel();

    private EditContext? editContext;

    private bool isValid = true;

    protected override async Task OnInitializedAsync()
    {
        await base.OnInitializedAsync();
        editContext = new EditContext(validationModel);

        // Manually re-render the page on state change as errors display based on 
        // form validation and API errors returned from the request as well
        State.StateChanged += DisplayValidationErrors;
    }

    private void OnSignInClicked()
    {
        // Do not allow the user to login if the form is invalid
        isValid = !(editContext is null) && editContext.Validate();

        if (isValid)
        {
            // The validation model ensures the strings are not null/empty, let the compiler know with the bang (!) operator
            var userLoginDto = new LoginUserDto(validationModel.Email!, validationModel.Password!);
            var userLoginRequest = new LoginUserRequest(userLoginDto);

            StateFacade.LoginUser(userLoginRequest);
        }
    }

    private void DisplayValidationErrors(object sender, UserState state)
    {
        if (state.HasCurrentErrors)
        {
            isValid = false;
        }
        else
        {
            isValid = true;
        }

        StateHasChanged();
    }
}
